我写了一个本地保存数据的隐私安全的聊天机器人，数据层分三层，indexeddb存储对话，cookie保持状态，zustandstore管理全局状态，为此我还写了一个dataservice层，代码如下：import { Conversation, Message } from "@/types/indexedDBSchema"; import Dexie from "dexie";  class AIAssistantDB extends Dexie {   conversations: Dexie.Table<Conversation, string>;   messages: Dexie.Table<Message, string>;    constructor() {     super("AIAssistantDB");     this.version(1).stores({       conversations: "id, title, createdAt, updatedAt",       messages:         "id, conversationId, assistantReply, userPrompt, timestamp",     });     this.conversations = this.table("conversations");     this.messages = this.table("messages");   } }  const db = new AIAssistantDB();  export default db; import db from "@/indexedDB/db"; import { chatWithDolphin } from "@/utils/chatwith-dolphin"; import { Conversation, Message } from "@/types/indexedDBSchema"; import { contextManager } from "./contextManager";  import { persistConversationState, loadConversationState } from "@/utils/persist-state";  export const dataService = {   async createConversation(title: string): Promise<string> {     const conversation: Conversation = {       id: Date.now().toString(),       title,       createdAt: new Date(),       updatedAt: new Date(),     };     await db.conversations.add(conversation);      await persistConversationState(conversation.id);      return conversation.id;   },    async getConversationContext(     conversationId: string,     latestUserPrompt: string   ): Promise<string> {     return contextManager.getConversationContext(       conversationId,       latestUserPrompt     );   },    async getConversation(id: string): Promise<Conversation | undefined> {     return db.conversations.get(id);   },    async getConversationList(): Promise<Conversation[]> {     return db.conversations.toArray();   },    async addMessage(     conversationId: string,     assistantReply: string,     userPrompt: string   ): Promise<void> {     const message: Message = {       id: Date.now().toString(),       conversationId,       assistantReply,       userPrompt,       timestamp: new Date(),     };     await db.messages.add(message);      await db.conversations.update(conversationId, { updatedAt: new Date() });   },    async getMessages(conversationId: string): Promise<Message[]> {     return db.messages       .where("conversationId")       .equals(conversationId)       .sortBy("timestamp");   },    async chatWithAI(     conversationId: string,     dolphinKey: string,     userMessage: string   ): Promise<object> {     const context = await this.getConversationContext(       conversationId,       userMessage     );     const replyData = await chatWithDolphin(context, dolphinKey);      await this.addMessage(conversationId, replyData.reply, userMessage);      await persistConversationState(conversationId);      console.log(context);     return replyData;   },    async regenerateReply(     conversationId: string,     dolphinKey: string,     userMessage: string   ): Promise<object> {     const context = await this.getConversationContextWithoutLastReply(       conversationId,       userMessage     );     const replyData = await chatWithDolphin(context, dolphinKey);      console.log(context);      await this.updateLastMessage(conversationId, replyData.reply);      await persistConversationState(conversationId);      return replyData;   },    async getConversationContextWithoutLastReply(     conversationId: string,     latestUserPrompt: string   ): Promise<string> {     const messages = await this.getMessages(conversationId);      messages.pop();      const conversationHistory = contextManager.buildConversationHistory(       messages,       latestUserPrompt     );      return contextManager.assembleContext(conversationHistory);   },    async updateLastMessage(     conversationId: string,     newReply: string   ): Promise<void> {     const messages = await this.getMessages(conversationId);     const lastMessage = messages[messages.length - 1];     if (lastMessage) {       lastMessage.assistantReply = newReply;       await db.messages.update(lastMessage.id, { assistantReply: newReply });     }   },    async getAllConversations(): Promise<Conversation[]> {     return db.conversations.toArray();   },    async deleteConversation(conversationId: string): Promise<void> {     await db.messages.where("conversationId").equals(conversationId).delete();     await db.conversations.delete(conversationId);   }, }; import { create } from "zustand"; import { Store , KeyActions } from "../types/store"; import Cookie from "js-cookie";   const useStore = create<Store & KeyActions>((set, get) => ({   bothKeyInCookie: false,   claudeKey: "",   dolphinKey: "",   currentConversationId: "",   conversationList: [],    setBothKeyInCookie: (bothKeyInCookie) => set({ bothKeyInCookie }),   setClaudeKey: (claudeKey) => set({ claudeKey }),   setDolphinKey: (dolphinKey) => set({ dolphinKey }),   setcurrentConversationId: (currentConversationId) => {     set({ currentConversationId });   },   setConversationList: (conversationList) => set({ conversationList }),    getCurrentConversationId: () => get().currentConversationId,    getKeysFromCookie: () => {     if (typeof window !== "undefined") {       const claudeKey = Cookie.get("claudeKey") || "";       const dolphinKey = Cookie.get("dolphinKey") || "";       const currentConversationId = Cookie.get("currentConversationId") || "";       set({         claudeKey,         dolphinKey,         currentConversationId,         bothKeyInCookie: !!(claudeKey && dolphinKey),       });     }   },   clearCookie: () => {     Cookie.remove("claudeKey");     Cookie.remove("dolphinKey");     Cookie.remove("currentConversationId");     set({       claudeKey: "",       dolphinKey: "",       currentConversationId: "",       bothKeyInCookie: false,     });   }, }));  export default useStore; import Cookie from "js-cookie"; import db from "@/indexedDB/db"; import useStore from "@/store/store";  export async function persistConversationState(conversationId: string) {   // Save the current conversation ID to a cookie   Cookie.set("currentConversationId", conversationId, { expires: 7 }); // Expires in 7 days    // Update the conversation's 'updatedAt' field in IndexedDB   await db.conversations.update(conversationId, { updatedAt: new Date() });      console.log("updated conversationId", conversationId);    // Optionally, you can also update your Zustand store   useStore.getState().setcurrentConversationId(conversationId); }  export async function loadConversationState(): Promise<string | null> {   const conversationId = Cookie.get("currentConversationId");    if (conversationId) {     // Verify that the conversation still exists in IndexedDB     const conversation = await db.conversations.get(conversationId);     if (conversation) {       useStore.getState().setcurrentConversationId(conversationId);       return conversationId;     } else {       // If the conversation doesn't exist, clear the cookie       Cookie.remove("currentConversationId");     }   }    return null; }  export async function clearConversationState() {   Cookie.remove("currentConversationId");   useStore.getState().setcurrentConversationId(""); } 我前端有一个侧边栏，显示对话记录，组件如下：import React from "react"; import { Message } from "@/types/indexedDBSchema";  interface CardProps {   messages: Message[]; }  export default function Card({ messages }: CardProps) {   return (     <div className="w-full max-w-5xl mx-auto space-y-4 overflow-y-auto max-h-[60vh] md:max-h-[80vh] p-4">       {messages.map((message, index) => (         <React.Fragment key={index}>           <div className="flex justify-start mb-2">             <div className="bg-gray-50 dark:bg-gray-400 rounded-lg p-3 max-w-[80%]">               {/* <p className="text-sm font-semibold mb-1">User</p> /}               <p className="text-sm">{message.userPrompt}</p>             </div>           </div>           <div className="flex justify-end mb-2">             <div className="bg-gray-100 dark:bg-gray-300 rounded-lg p-3 max-w-[80%]">               {/ <p className="text-sm font-semibold mb-1">Assistant</p> */}               <p className="text-sm">{message.assistantReply}</p>             </div>           </div>         </React.Fragment>       ))}     </div>   ); } import React from "react";  interface DialogTitleProps {   title: string; }  export default function DialogTitle({ title }: DialogTitleProps) {   return (     <div className="mt-8 w-3/4">       <h1 className="text-center text-sm md:text-base text-primary/80">         {title}       </h1>     </div>   ); } 'use client';  import React, { useState, useEffect } from "react"; import Card from "./dialogcard"; import DialogForm from "./inputform"; import DialogTitle from "./dialogtitle"; import useStore from "@/store/store"; import { dataService } from "@/services/dataService"; import { Message } from "@/types/indexedDBSchema"; import {   persistConversationState,   loadConversationState, } from "@/utils/persist-state"; import { RefreshCw } from "lucide-react";  export default function ChatBox() {   const [title, setTitle] = useState("New Conversation");   const [messages, setMessages] = useState<Message[]>([]);   const [isRegenerating, setIsRegenerating] = useState(false);   const {     dolphinKey,     currentConversationId,     setcurrentConversationId,     getCurrentConversationId,     conversationList,     setConversationList,   } = useStore();    useEffect(() => {     const initializeConversation = async () => {       const savedConversationId = await loadConversationState();       if (savedConversationId) {         setcurrentConversationId(savedConversationId);         loadConversation(savedConversationId);       }     };      initializeConversation();   }, []);    useEffect(() => {          if (currentConversationId) {       loadConversation(currentConversationId);     } else {       setTitle("New Conversation");       setMessages([]);     }   }, [currentConversationId]);    const loadConversation = async (id: string) => {     const conversation = await dataService.getConversation(id);     if (conversation) {       setTitle(conversation.title);       const msgs = await dataService.getMessages(id);       setMessages(msgs);     }   };    const handleNewMessage = async (userMessage: string) => {     let conversationId = getCurrentConversationId();          if (!currentConversationId) {       conversationId = await dataService.createConversation(userMessage);       setcurrentConversationId(conversationId);       setTitle(userMessage);       await persistConversationState(conversationId);       conversationId = getCurrentConversationId();     }      const replyData = await dataService.chatWithAI(       conversationId,       dolphinKey,       userMessage     );      console.log("replyData", replyData);      const updatedMessages = await dataService.getMessages(       conversationId     );        setMessages(updatedMessages);      const conversationList = await dataService.getConversationList();     setConversationList(conversationList);   }    const handleRegenerate = async () => {     if (messages.length === 0 || !currentConversationId) return;      setIsRegenerating(true);      try {       const lastMessage = messages[messages.length - 1];       const replyData = await dataService.regenerateReply(         currentConversationId,         dolphinKey,         lastMessage.userPrompt       );        const updatedMessages = await dataService.getMessages(currentConversationId);       setMessages(updatedMessages);     } catch (error) {       console.error("Error regenerating reply:", error);     } finally {       setIsRegenerating(false);     }   };    return (     <div className="z-10 flex flex-col justify-between items-center grow">       <DialogTitle title={title} />       <Card messages={messages} />       {currentConversationId && (          <div className="flex items-center space-x-2 ">           <div className="text-primary/80 text-xs">Regenerate last message</div>           <button             title="Regenerate last message"             onClick={handleRegenerate}             disabled={isRegenerating || messages.length === 0}             className="mr-2 p-2 rounded-full bg-gray-200 hover:bg-gray-300 disabled:opacity-50"           >             <RefreshCw               size={15}               className={isRegenerating ? "animate-spin" : ""}             />           </button>         </div>       )}       <DialogForm onSendMessage={handleNewMessage} />     </div>   ); } import React, { useRef, useEffect, useState } from "react"; import Image from "next/image";  interface DialogFormProps {   onSendMessage: (message: string) => Promise<void>; }  export default function DialogForm({ onSendMessage }: DialogFormProps) {   const textareaRef = useRef<HTMLTextAreaElement>(null);   const [message, setMessage] = useState("");   const [isLoading, setIsLoading] = useState(false);    const adjustHeight = () => {     const textarea = textareaRef.current;     if (textarea) {       textarea.style.height = "auto";       textarea.style.height = ${textarea.scrollHeight}px;     }   };    useEffect(() => {     const textarea = textareaRef.current;     textarea?.addEventListener("input", adjustHeight);     return () => textarea?.removeEventListener("input", adjustHeight);   }, [message]);    const handleKeyDown = async (     event: React.KeyboardEvent<HTMLTextAreaElement>   ) => {     if (event.key === "Enter" && !event.shiftKey) {       event.preventDefault(); // 防止换行        if (message.trim()) {         setIsLoading(true);         try {            await onSendMessage(message);           setMessage("");           setTimeout(adjustHeight, 0);          } catch (error) {           console.error("Error sending message:", error);         } finally {           setIsLoading(false);         }       }     }   };    return (     <div className="w-full flex justify-center">       <div className="relative w-3/4 md:w-7/12 xl:w-4/12">         <label htmlFor="dialog" className="sr-only">           Your reply         </label>         <textarea           ref={textareaRef}           id="dialog"           name="dialog"           placeholder="your reply:"           value={message}           onChange={(e) => setMessage(e.target.value)}           onKeyDown={handleKeyDown}           disabled={isLoading}           className={block w-full pr-10 mb-2 rounded-md border-0 py-1.5 text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 placeholder:text-gray-400 focus:ring-2 focus:ring-inset focus:ring-primary/80 sm:text-sm sm:leading-6 resize-none overflow-hidden min-h-[40px] ${             isLoading ? "opacity-50" : ""           }}         />         {isLoading && (           <div className="absolute right-2 top-1/2 transform -translate-y-1/2">             <Image               src="/loading.svg"               alt="Loading"               width={24}               height={24}               className="animate-spin"             />           </div>         )}       </div>     </div>   ); } 目前我想加一个功能，就是在每一个conversation右边加一个小的垃圾桶图标，然后点击图标会让用户确认是否删除该条conversation, 用户确认后删除。前后端应该如何修改？
我想的是能不能把chatlist组件的这个部分<nav className="flex flex-1 flex-col">             <ul role="list" className="flex flex-1 flex-col gap-y-7">               <li>                 <ul role="list" className="-mx-2 space-y-1">                   {conversationList.map((item) => (                     <li key={item.id}>                       <div                         onClick={() => handleConversationClick(item.id)}                         className={block rounded-md py-2 pl-10 pr-2 text-sm font-semibold leading-6 cursor-pointer ${                           currentConversationId === item.id                             ? "bg-gray-100 text-zinc-950"                             : "text-primary/80 hover:bg-gray-50 hover:text-zinc-950"                         }}                       >                         {item.title}                       </div>                     </li>                   ))}                 </ul>               </li>             </ul>           </nav> 抽取出来，单独写一个conversations组件，然后把功能写在里面，然后在导入chatlist组件使用